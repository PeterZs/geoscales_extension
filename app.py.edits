#!flask/bin/python
from flask import Flask, render_template, jsonify
from functions import *
from flask import request
from settings import APP_STATIC
import sys
import csv
import os
import json
import re
import collections

app = Flask(__name__)
lat = 0.0
lon = 0.0
with open(os.path.join(APP_STATIC, 'scales2015Master_with_flickr_no_cities_final.csv')) as f:
        flickr = [row for row in csv.reader(f.read().splitlines())]
        flickr_dict = dict()
        for ent in flickr:
                flickr_dict[ent[1]] = ent[-1]
# area
with open(os.path.join(APP_STATIC, 'area_only_park_new_final.csv')) as f:
        csvreader = [row for row in csv.reader(f.read().splitlines())]
with open(os.path.join(APP_STATIC, 'area_boundary_with_q.csv')) as f:
        area_boundary = [row for row in csv.reader(f.read().splitlines())]
with open(os.path.join(APP_STATIC, 'city_with_country.csv')) as f:
                city = [row for row in csv.reader(f.read().splitlines())]
city_matching_dict = dict()
for line in city:
        cityname = line[0]
        countryname = line[1]
        citylat = line[2]
        citylon = line[3]
        key = (cityname,countryname)
        city_matching_dict.update({key:(citylat,citylon)})
country_mathing_dict = dict()
with open(os.path.join(APP_STATIC, 'final_country_new.csv')) as f:
        country = [row for row in csv.reader(f.read().splitlines())]
# key(city:washington), city area, state area, state centroids
with open(os.path.join(APP_STATIC, 'uscitystate_new.csv')) as f:
        uscitystate = [row for row in csv.reader(f.read().splitlines())]

with open(os.path.join(APP_STATIC, 'state.csv')) as f:
        usstate = [row for row in csv.reader(f.read().splitlines())]


singlePolygon =  open(os.path.join(APP_STATIC, 'final_polygon.csv'),'r')
topojson_world =  open(os.path.join(APP_STATIC, 'world-country-names.tsv'),'r')
topojson_us =  open(os.path.join(APP_STATIC, 'us-state-names.tsv'),'r')

country_mathing_dict = dict()
country_polygon_dict = dict()
citystate_dict = dict()
state_dict = dict()
topojson_dict = dict()
topojson_dict_state = dict()

for line in country:
        countryInd = line[0]
        countryName = line[1]
        centroid_lat = line[4]
        centroid_lon = line[5]
        countryArea = line[6]
        country_mathing_dict.update({countryName:(countryInd,centroid_lat, centroid_lon,countryArea)})
for line in singlePolygon:
        temp = line.split(":")
        countryPolygonId = temp[0]
        countryRealPolygon = temp[1]
        country_polygon_dict.update({countryPolygonId:countryRealPolygon})

for line in uscitystate:
        key = line[0]
        cityArea = line[1]
        stateArea = line[2]
        state_lat =line[3]
        state_lon = line[4]
        citystate_dict.update({key:(cityArea,stateArea,state_lat,state_lon)})
for line in usstate:
        key = line[0]
        stateArea = line[1]
        state_lat =line[2]
        state_lon = line[3]
        state_dict.update({key:(stateArea,state_lat,state_lon)})

for line in topojson_world:
        temp = line.split("\t")
        topoid = temp[0]
        countryname = temp[1].strip()
        topojson_dict.update({countryname:topoid})

for line in topojson_us:
        temp = line.split("\t")
        topoid = temp[0]
        statename = temp[2].strip()
        topojson_dict_state.update({statename:topoid})
resultN = 1
@app.route('/todo/api/v1.0/area/', methods=['POST'])
def get_task_area():
        with open(os.path.join(APP_STATIC, 'area_only_park_new_final.csv')) as f:
                csvreader = [row for row in csv.reader(f.read().splitlines())]
        with open(os.path.join(APP_STATIC, 'area_boundary_with_q.csv')) as f:
                area_boundary = [row for row in csv.reader(f.read().splitlines())]
        data = request.get_json(force=True)
        location = data["location"]
        lat = location[0]
        lon = location[1]
        #area
        myyard= "y"
        myacre="acre"
        mymile = "mi"
        mykm = "k"
        myft = "f"
        print getAddress(lat,lon)
        city, state = getAddress(lat,lon)
        areaData = data["area"]
        keyword = areaData[0]
        measurement = areaData[1]
        unit = areaData[2]
        weightD = areaData[3]
        weightM = areaData[4]
        weightF = areaData[5]
        resultN = areaData[6]
        measurement = float(measurement)
        if re.match(myyard, unit) is not None:
                converted = measurement * 0.836127
        if re.match(myacre, unit) is not None:
                converted = measurement * 4046.856
        if re.match(mymile, unit) is not None:
                converted = measurement * 2589990
        if re.match(mykm, unit) is not None:
                converted = measurement * 1000000
        if re.match(myft, unit) is not None:
                converted = measurement * 0.092903

        result = getRowsArea(keyword, flickr_dict,city,resultN,csvreader,lat,lon,converted,weightD,weightM,weightF,area_boundary,unit)
        return jsonify({"area":result})

@app.route('/todo/api/v1.0/distance/',methods=['POST'])
def get_tasks_distance():
        data = request.get_json(force=True)
        location = data["location"]
        #print location
        lat = location[0]
        lon = location[1]
        city, state = getAddress(lat,lon)
        myyardd= "y"
        mymiled = "mi"
        mykmd = "k"
        myftd = "f"
        mymeterd ='meter'
        distanceData = data["distance"]
        keyword = distanceData[0]
        measurement = distanceData[1]
        unit = distanceData[2]
        weightD = distanceData[3]
        weightF = distanceData[4]
        weightM = distanceData[5]
        resultN = distanceData[6]
        try:
                measurement = float(measurement.replace(",",''))
        except:
                pass
        converted = measurement
        if re.match(myyardd, unit) is not None:
                converted = measurement * 0.0009144
        if re.match(mymiled, unit) is not None:
                converted = measurement * 1.60934
        if re.match(mykmd, unit) is not None:
                converted = measurement
        if re.match(myftd, unit) is not None:
                converted = measurement * 0.0003048
        if re.match(mymeterd, unit) is not None:
                converted = measurement * 0.001
        print lat, lon
        result = getRowsDistance(keyword, flickr_dict,city,resultN,flickr,lat,lon,converted,weightD,weightM,weightF,unit)
        # return jsonify({"distance":returnResult})
        return jsonify({"distance":result})


@app.route('/todo/api/v1.0/cc/',methods=['POST'])
def get_tasks_city_country():
        data = request.get_json(force=True)
        topojson_world =  open(os.path.join(APP_STATIC, 'world-country-names.tsv'),'r')
        topojson_us =  open(os.path.join(APP_STATIC, 'us-state-names.tsv'),'r')
        topojson_dict = dict()
        topojson_dict_state = dict()
        location = data["location"]
        lat = location[0]
        lon = location[1]
        this_country = data["country"][0]
        city, state = getAddress(lat,lon)
        print "in the app.py", city, state
        returnResult = list()
        with open(os.path.join(APP_STATIC, 'city_with_country.csv')) as f:
                city = [row for row in csv.reader(f.read().splitlines())]
        city_matching_dict = dict()
        for line in city:
                cityname = line[0]
                countryname = line[1]
                citylat = line[2]
                citylon = line[3]
                key = (cityname,countryname)
                city_matching_dict.update({key:(citylat,citylon)})
        country_mathing_dict = dict()
        with open(os.path.join(APP_STATIC, 'final_country_new.csv')) as f:
                country = [row for row in csv.reader(f.read().splitlines())]
        # key(city:washington), city area, state area, state centroids
        with open(os.path.join(APP_STATIC, 'uscitystate_new.csv')) as f:
                uscitystate = [row for row in csv.reader(f.read().splitlines())]

        with open(os.path.join(APP_STATIC, 'state.csv')) as f:
                usstate = [row for row in csv.reader(f.read().splitlines())]
        singlePolygon =  open(os.path.join(APP_STATIC, 'final_polygon.csv'),'r')

        country_mathing_dict = dict()
        country_polygon_dict = dict()
        citystate_dict = dict()
        state_dict = dict()

        for line in country:
                countryInd = line[0]
                countryName = line[1]
                centroid_lat = line[4]
                centroid_lon = line[5]
                countryArea = line[6]
                country_mathing_dict.update({countryName:(countryInd,centroid_lat, centroid_lon,countryArea)})
        for line in singlePolygon:
                temp = line.split(":")
                countryPolygonId = temp[0]
                countryRealPolygon = temp[1]
                country_polygon_dict.update({countryPolygonId:countryRealPolygon})

        for line in uscitystate:
                key = line[0]
                cityArea = line[1]
                stateArea = line[2]
                state_lat =line[3]
                state_lon = line[4]
                citystate_dict.update({key:(cityArea,stateArea,state_lat,state_lon)})
        for line in usstate:
                key = line[0]
                stateArea = line[1]
                state_lat =line[2]
                state_lon = line[3]
                state_dict.update({key:(stateArea,state_lat,state_lon)})

        for line in topojson_world:
                temp = line.split("\t")
                topoid = temp[0]
                countryname = temp[1].strip()
                topojson_dict.update({countryname:topoid})
        # remove all tag
        # no consideration on the contents in the parenthesis (=xx bigger than Seattle Center)
        returnResult = cityCountryTagger(lat,lon,city,state,citystate_dict, state_dict,this_country, country_mathing_dict,topojson_dict)

        return jsonify({"cc":returnResult})

# def sort_and_deduplicate(l):
#     return list(uniq(sorted(l, reverse=True)))

@app.route('/todo/api/v1.0/merge/',methods=['POST'])
def get_data():
        resultN = 1
        data = request.get_json(force=True)
        lat = data["locationObj"]["location"][0]
        lon = data["locationObj"]["location"][1]
        city, state = getAddress(lat,lon)
        print city, state, "This is it"
        distanceData = data["distanceMatchOjb"]["distance"]
        areaData = data["areaMatchOjb"]["area"]
        try:
                countryData = data["countryMatchOjb"]["country"]
        except:
                countryData = data["countryOjb"]["country"]
        stateData = data["stateOjb"]["state"]
        distanceData = list(sort_and_deduplicate(distanceData))
        areaData = list(sort_and_deduplicate(areaData))
        returnResultDistance = list()
        returnResultArea = list()

        # distance 
        myyardd= "y"
        mymiled = "mi"
        mykmd = "k"
        myftd = "f"
        mymeterd ='meter'

        for keyword, measurement, unit in distanceData:
                measurement = float(measurement.replace(",",''))
                # print "unit", repr(unit)
                converted = measurement
                if re.match(myyardd, unit) is not None:
                        converted = measurement * 0.0009144
                if re.match(mymiled, unit) is not None:
                        converted = measurement * 1.60934
                if re.match(mykmd, unit) is not None:
                        converted = measurement
                if re.match(myftd, unit) is not None:
                        converted = measurement * 0.0003048
                if re.match(mymeterd, unit) is not None:
                        converted = measurement * 0.001


                result = getRowsDistance(keyword, flickr_dict,city,resultN,flickr,lat,lon,converted,0,4,1,unit)
                returnResultDistance.append(result)


        myyard = "squ?a?r?e?\.?(\s|-)y"
        #myyard2 = "sq\.?(\s|-)y"
        myacre ="acre"
        mymile = "squ?a?r?e?\.?(\s|-)mi"
        #mymile2 = "sq\.?(\s|-)mi"
        mykm = "squ?a?r?e?\.?(\s|-)k"
        #mykm2 = "sq\.(\s|-)k"
        myft = "squ?a?r?e?\.?(\s|-)f"
        #myft2 = "sq\.(\s|-)f"

        for keyword, measurement, unit in areaData:
                measurement = float(measurement.replace(",",''))
                print "measurement", repr(measurement)
                print "unit", repr(unit)
                converted = measurement
                if re.match(myyard, unit) is not None:
                        converted = measurement * 0.836127
                if re.match(myacre, unit) is not None:
                        converted = measurement * 4046.856
                if re.match(mymile, unit) is not None:
                        converted = measurement * 2589990
                if re.match(mykm, unit) is not None:
                        converted = measurement * 1000000
                if re.match(myft, unit) is not None:
                        converted = measurement * 0.092903
                # pass keyword to get replaced later 
                result = getRowsArea(keyword, flickr_dict,city,resultN,csvreader,lat,lon,converted,4,20,1,area_boundary,unit)
                #weightD, weightM, weightF
                #city boundary should be used later to map
                returnResultArea.append(result)

        # CC



        #returnResultState = stateTagger(stateData,lat,lon,city, state,city_matching_dict, country_mathing_dict, citystate_dict, state_dict,topojson_dict_state)
        returnResultState = ''
        print "app.py state:", state
        returnResultCountry = cityCountryTagger(countryData,lat,lon,city,state,city_matching_dict, country_mathing_dict, citystate_dict, state_dict,country_polygon_dict,topojson_dict)

        returnResultFinal = {"distance":returnResultDistance, "area":returnResultArea, "country":returnResultCountry, "state":returnResultState}
        return jsonify({"result":returnResultFinal})


@app.route('/todo/api/v1.0/distanceforcity/',methods=['POST'])
def get_tasks_city_distance():
        weightD = 0
        weightM = 4
        weightF = 1
        data = request.get_json(force=True)
        citydistance = data["citydistance"]

        city1lat = float(citydistance[0])
        city1lon = float(citydistance[1])
        city2lat = float(citydistance[2])
        city2lon = float(citydistance[3])
        lat = citydistance[4]
        lon = citydistance[5]
        # returnResult = getRowsDistance(keyword, flickr_dict,city,resultN,flickr,lat,lon,converted,weightD,weightM,weightF)
        returnResult = getRowsCityDistance(city1lat,city1lon,city2lat,city2lon,lat,lon,flickr_dict,resultN,weightD,weightM,weightF,flickr)
        return jsonify({"citydistance":returnResult})


@app.after_request
def after_request(response):
        response.headers.add('Access-Control-Allow-Origin', '*')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
        response.headers.add('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE')
        return response

def shutdown_request(self,request):
        request.shutdown()


if __name__ == '__main__':
        port = 5000
        # context = ('/etc/ssl/certs/visualization.ischool.uw.edu.pem','/etc/ssl/private/visualization.ischool.uw.edu.key')
        # app.run(host='128.95.157.108', port=port, debug=True, ssl_context=context)
        app.run(host='128.95.157.108', port=port, debug=True)
        # app.run(host='localhost', port=port, debug=True)
